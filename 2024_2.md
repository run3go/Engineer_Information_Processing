# 정보처리기사 실기 2020년 2회

## 1. 다음 Java로 구현된 프로그램을 분석하여 그 실행 결과를 쓰시오.

```java
class Main {
    public static void main(String[] args) {
        int[] a = new int[]{1, 2, 3, 4};
        int[] b = new int[]{1, 2, 3, 4};
        int[] c = new int[]{1, 2, 3};

        check(a, b);
        check(a, c);
        check(b, c);
    }

    public static void check(int[] a, int[] b) {
        if (a==b) {
            System.out.print("O");
        }else{
            System.out.print("N");
        }

    }
}
```

<details>
<summary>정답</summary>

**_NNN_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. 정수 배열 `a`, `b`, `c`를 초기화
2. `check` 메서드를 호출
   - 두 배열을 매개변수로 받음
   - `a==b` 두 배열의 주소가 일치해야 조건 일치
3. `check(a, b)`: 배열의 원소는 완전히 일치하지만, 두 배열은 다른 주소를 참조하기 때문에 `false` (N)
4. `check(a, c)`, `check(b, c)`: 배열의 주소, 원소 모두 불일치
5. <b>출력</b>: NNN

</div>

</details>

## 2. 다음 내용이 설명하는 용어를 쓰시오.

시스템의 성능을 향상시키고 개발 및 운영의 편의성 등을 높이기 위해 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위

<details>
<summary>정답</summary>

**_비정규화_**

</details>

## 3. 다음은 SQL에 관한 문제이다. 아래 SQL 구문의 빈칸을 작성하시오.

[테이블]

사원 [사원번호(PK), 이름, 나이, 부서]
부서 [사원번호(PK), 이름, 주소, 나이]

1. 신입사원이 들어와서 부서 테이블에 새로운 사람을 추가
   INSERT INTO 부서 (사원번호, 이름, 주소, 나이) ( ① ) (240728, '홍길동', '서울', 30);

2. 부서 테이블에서 추가한 사원을 검색한 후 사원 테이블에 추가
   INSERT INTO 사원 (사원번호, 이름, 나이, 부서)
   ( ② ) 사원번호, 이름, 나이, ‘영업’ FROM 부서 WHERE 이름 = '홍길동';

3. 전체 사원 테이블 조회
   SELECT \* ( ③ ) 사원;

4. 사원의 퇴사로 인해 부서에 해당하는 값을 '퇴사'로 변경
   UPDATE 사원 ( ④ ) 부서 = '퇴사' WHERE 사원번호 = 240728;

<details>
<summary>정답</summary>

**_1) values 2) select 3) from 4) set_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. 부서 테이블에 새로운 사람을 추가
   - `INSERT INTO 부서 (사원번호, 이름, 주소, 나이) (1) (240728, '홍길동', '서울', 30)`
   - INSERT INTO문에서 데이터 값들을 명시하기 위해 `values`를 사용해야 한다.
2. 추가한 사원을 검색한 후 사원 테이블에 추가
   - `INSERT INTO 사원 (사원번호, 이름, 주소, 나이) (2) 사원번호, 이름, 나이, '영업' FROM 부서 WHERE 이름 = '홍길동'`
   - `select`를 통해 '부서' 테이블에서 값을 가져와 INSERT 할 수 있다.
3. 전체 사원 테이블 조회
   - `SELECT * (3) 사원`
   - 테이블을 참조할 때는 `from`을 사용한다.
4. 부서에 해당하는 값을 '퇴사'로 변경
   - `UPDATE 사원 (4) 부서 = '퇴사' WHERE 사원번호 = 240728`
   - UPDATE 문에서는 `set`을 사용하여 변경할 컬럼과 값을 지정한다.

</div>

</details>

## 4. 다음 릴레이션의 Cardinality와 Degree를 작성하시오.

![4번 문제 사진](image-18.png)

Cardinality : ( ① )

Degree : ( ② )

<details>
<summary>정답</summary>

**_1) 5 2) 4_**

</details>

## 5. 다음은 프로토콜에 대한 내용이다. 아래 내용을 읽고 알맞는 답을 작성하시오.

- Network layer에서 IP패킷을 암호화하고 인증하는 등의 보안을 위한 표준이다.
- 기업에서 사설 인터넷망으로 사용할 수 있는 VPN을 구현하는데 사용되는 프로토콜이다.
- AH(Authentication Header)와 ESP(Encapsulating Security Payload)라는 두 가지 보안 프로토콜을 사용한다.

<details>
<summary>정답</summary>

**_IPSec_**

<b>키워드: 암호화, 인증, AH, ESP</b>

</details>

## 6. 다음은 Python에 대한 문제이다. 아래 코드를 읽고 알맞는 출력 값을 작성하시오.

```python
def fnCalculation(x,y):
    result = 0;
    for i in range(len(x)):
     temp = x[i:i+len(y)]
     if temp == y:
       result += 1;
    return result

a = "abdcabcabca"
p1 = "ab";
p2 = "ca";

out = f"ab{fnCalculation(a,p1)}ca{fnCalculation(a,p2)}"
print(out)
```

<details>
<summary>정답</summary>

**_ab3ca3_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

<b>f-string</b>: 사용방법은 <b style="text-decoration:underline">문자열 앞에 접두사 f를 붙이고, 중괄호 `{}` 안에 변수를 넣는 것</b>이다.

1. 원본 문자열: `"abdcabcabca"`
2. 찾을 패턴1: `"ab"`
3. 찾을 패턴2: `"ca"`
4. `fnCalculation()` 함수 호출
   - `for i in range(len(x)):` 문자열 `x`의 길이만큼 반복(11)
   - `temp = x[i:i+len(y)]`: i부터 문자열 `y`의 길이만큼 자름
     - `ab, bd, dc, ca, ab, bc, ca, ab, bc, ca`
   - `if temp == y:`: 문자열 `y`와 비교하여 일치하면 result + 1
     - `y = ab`: result = 3
     - `y = ca`: result = 3
5. `f"ab{fnCalculation(a,p1)}ca{fnCalculation(a,p2)}"`: f-string의 내부 함수를 계산한 결과
   - `ab3ca3`
6. <b>출력</b>: ab3ca3

</div>

</details>

## 7. 아래 설명하는 내용을 확인하여 알맞는 알고리즘을 작성하시오.

- 대칭키 알고리즘으로 1997년 NIST(미국 국립기술표준원)에서 DES를 대체하기 위해 생성되었다.
- 128비트, 192비트 또는 256비트의 가변 키 크기와 128비트의 고정 블록 크기를 사용한다.
- 높은 안전성과 효율성, 속도 등으로 인해 DES 대신 전 세계적으로 많이 사용되고 있다.

<details>
<summary>정답</summary>

**_AES_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

- <b>DES(Data Encryption Standard)</b>

  - 1977년 미국의 연방정보처리 표준 규격(FIPS)로 채택된 대칭 암호
  - <b style="text-decoration:underline">56비트의 키</b>를 이용하는 대칭키 암호시스템
  - <b style="text-decoration:underline">페이스텔 구조</b>의 암호화 방식

- <b>AES(Advanced Encryption Standard)</b>
  - 1997년 NIST에서 <b style="text-decoration:underline">DES를 대체</b>하기 위해 생성
  - 128비트 평문을 <b style="text-decoration:underline">128비트로 암호화</b>
  - <b style="text-decoration:underline">비페이스텔 구조</b>의 암호화 바익

</div>

</details>

## 8. 패킷 교환 방식 중에 연결형과 비연결형에 해당하는 방식을 작성하시오.

① 연결형 교환 방식

② 비연결형 교환 방식

<details>
<summary>정답</summary>

**_1. 가상 회선 2. 데이터그램_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

- <b>가상 회선(Virtual Circuit)</b>: 통신 전에 <b style="text-decoration:underline">논리적인 경로를 미리 설정</b>하여 동일한 경로로 패킷을 전송하는 방식
  - 마치 전용 회선을 설정한것처럼 동작하지만, 실제로는 여러 사용자가 물리적 회선을 공유하는 방식
  - 연결형 서비스
- <b>데이터그램 방식(Datagram)</b>: 데이터를 패킷(데이터그램) 단위로 나누어, 각 패킷이 <b style="text-decoration:underline">독립적으로 경로를 결정하여 전송</b>하는 패킷 교환 방식
  - 각 패킷이 도착한 순서가 달라질 수 있고, 네트워크 상황에 따라 최적의 경로가 변경될 있음
  - 비연결형 서비스

</div>

</details>

## 9. 모듈에 대한 다음 설명에 해당하는 응집도(Cohesion)를 에서 찾아 쓰시오.

실행 순서가 밀접한 관계를 갖는 기능을 모아 모듈로 구성한다.
한 모듈 내부의 한 기능 요소에 의한 출력 자료가 다음 기능 원소의 입력 자료로서 제공되는 형태이다.

보기

ㄱ. 기능적(functional) ㄴ. 우연적(Coincidental) ㄷ. 통신적(Communication) ㄹ. 절차적(Procedural) ㅁ. 시간적(Temporal) ㅂ. 순차적(sequential) ㅅ. 논리적(Logical)

<details>
<summary>정답</summary>

**_ㅂ. 순차적_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

<b>응집도(Cohesion)</b>: 하나의 클래스가 기능에 집중하기 위한 모든 정보의 역할을 갖고 있어야 한다는 의미이다.

1. <b>기능적 응집도(Funcional)</b>
   - 가장 응집도가 높은 형태로 가장 좋은 형태
   - 모듈 내부의 모든 기능이 <b style="text-decoration:underline">단일 목적</b>을 위해 수행되는 경우
2. <b>순차적 응집도(Sequential)</b>
   - 모듈 내에서 한 활동으로 부터 나온 <b style="text-decoration:underline">출력값이 다음 활동의 입력 데이터로 사용</b>될 경우
   - 어떤 모듈이 특정 파일을 읽고 처리하는 기능을 하는 것
3. <b>교환적 응집도(Communicaion)</b>
   - 통신적 응집도라고도 불림
   - <b style="text-decoration:underline">동일한 입력과 출력을 사용해 서로 다른 기능을 수행</b>하는 구성요소들이 모였을 경우의 응집도
4. <b>절차적 응집도(Procedural)</b>
   - 하나의 모듈이 <b style="text-decoration:underline">특정한 순서</b>로 수행되어야 하는 여러 작업을 포함하지만, 그 작업들이 논리적으로 밀접하게 관련되어 있지 않은 경우
   - 순서상 같이 수행되기 때문에 묶여 있는 것이지, 하나의 목적이나 공통 데이터 때문에 묶인 거은 아니다.
5. <b>시간적 응집도(Temporal)</b>
   - 일시적 응집도라고도 불림
   - 각 기능 요소들이 <b style="text-decoration:underline">순서에 상관없이 특정 시점에 반드시 수행</b>되는 경우
   - 연관된 기능이라기 보단 특정 시간에 처리되어야하는 활동들을 한 모듈에서 처리하는 경우
6. <b>논리적 응집도(Logical)</b>
   - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우
   - 논리적 비슷한 기능을 수행하지만 <b style="text-decoration:underline">서로의 관계는 밀접하지 않은</b> 형태
   - switch문이 쓰여 case에 따라 비슷하지만 다른 작업을 수행하는 경우
7. <b>우연적 응집도(Coincidental)</b>
   - 가장 좋지 않은 응집도
   - 모듈 내부의 각 구성 요소들이 서로 관련업는 요소로만 구성된 경우

</div>

</details>

## 10. 아래는 디자인 패턴에 관한 설명이다. 아래 설명을 읽고 보기에서 알맞는 용어를 작성하시오.

- 컬렉션 객체의 내부 구조를 노출하지 않고 순차적으로 접근할 수 있게 하는 패턴이다.
- 이 패턴은 객체의 내부 표현 방식에 독립적으로 요소에 접근할 수 있도록 해준다
- 반복 프로세스를 캡슐화하여 클라이언트 코드에서는 컬렉션의 구체적인 구현에 종속되지 않도록 한다.

![10번 문제 사진](image-19.png)

<details>
<summary>정답</summary>

**_Iterator_**

<b>키워드: 순차적, 컬렉션</b>

</details>

## 11. 다음 라우터 A에서 라우터 F까지 경로를 설정하기 위해 RIP 방식을 사용한다고 할 때, 라우터가 지나가는 경로를 순서대로 쓰시오.(단, 간선 위의 숫자는 라우터 간의 거리를 의미한다.)

![11번 문제 사진](image-20.png)

<details>
<summary>정답</summary>

**_A->D->C->F_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

<b>RIP(Routing Informaion Protocol)</b>: 홉 수(경유하는 라우터 수)를 기준으로 최단 경로를 찾아 라우팅 테이블을 갱신

- A->D->C->F

<b>OSPF(Open Shortest Path First)</b>: 링크 상태 기반으로 경로 비용을 계산한다.

- A->D->C->E->F

<b>EIGRP(Enhanced Interior Gateway Routing Protocol)</b>: 기본적으로 대역폭이 낮고 지연이 적은 경로를 선호하며, 실제로는 비용이 다르게 계산됩니다.

- 그림에 표시된 숫자를 단순 비용으로 사용하면 OSPF와 동일하게 동작할 가능성이 크다.
- A->D->C->E->F

<b>Static Routing</b>: 정적 라우팅은 관리자가 경로를 직접 설정하므로 네트워크 설계자에 따라 경로가 결정된다.

- 마찬가지로 비용이 가장 적은 경로로 설정될 가능성이 크다.
- A->D->C->E->F

</div>

</details>

## 12. 아래의 표를 확인하여 SRT 스케줄링의 평균 대기시간을 계산하여 작성하시오.

![12번 문제 사진](image-21.png)

<details>
<summary>정답</summary>

**_6.5_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. A(0ms~1ms): 8 - 1 = 7
2. B(1ms~5ms): 4 - 4 = 0
3. D(5ms~10ms): 5 - 5 = 0
4. A(10ms~17ms): 7 - 7 = 0
5. C(17ms~25ms): 9 - 9 = 0

- <b>대기시간</b>: A(10-1=9), B(0), C(17-2=15), D(5-3=2)
- (9 + 15 + 2) / 4 = 26 / 4 = 6.5

</div>

</details>

## 13. 다음은 C언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.

```c
#include <stdio.h>

int main() {
    int arr[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int* parr[2] = {arr[1], arr[2]};
    printf("%d", parr[1][1] + *(parr[1]+2) + **parr);

    return 0;
}
```

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. 이중 정수 배열 `arr`
2. 배열 `arr`의 주소를 담은 포인터 배열 `parr`
3. `parr[1][1] + *(parr[1]+2) + **parr`
   - `parr[1][1]` = `arr[2][1]` = 8
   - `*(parr[1]+2)` = `*(arr[2]+2)` = `arr[2][2]` = 9
   - `**parr` = `arr[1][0]` = 4
   - 8 + 9 + 4 = 21
4. <b>출력</b>: 21

</div>

</details>

## 14. 다음은 Java 언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.

```java
class Main {
    public static void main(String[] args) {
        int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        ODDNumber OE = new ODDNumber();
        System.out.print(OE.sum(a, true) + ", " + OE.sum(a, false));
    }
}

interface Number {
    int sum(int[] a, boolean odd);
}

class ODDNumber implements Number {
    public int sum(int[] a, boolean odd) {
        int result = 0;
        for(int i=0; i < a.length; i++){
            if((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0))
                result += a[i];
        }
        return result;
    }
}
```

<details>
<summary>정답</summary>

**_25, 20_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. `ODDNumber` 인스턴스를 생성
2. `OE.sum()`
   - `if((odd && a[i] % 2 != 0) || (!odd && a[i] % 2 == 0))`: (매개변수 `odd`의 값이 `true`이고, `a[i]`가 홀수)거나, (`odd`의 값이 `false`이고, `a[i]`가 짝수)일 경우
   - `result += a[i]`: 그 값을 `result`에 더함
3. `OE.sum(a, true)`: 홀수 원소를 모두 더함 (1+3+5+7+9=25)
4. `OE.sum(a, false)`: 짝수 원소를 모두 더함 (2+4+6+8=20)
5. <b>출력</b>: 25, 20

</div>

</details>

## 15. 다음은 C언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력값을 작성하시오.

```c
#include <stdio.h>
#include <string.h>

void sumFn(char* d, const char* s) {

    while (*s) {
        *d = *s;
        d++;
        s++;
    }
    *d = '\0';
}

int main() {
   const char* str1 = "first";
    char str2[50] = "teststring";
    int result=0;
    sumFn(str2, str1);

    for (int i = 0; str2[i] != '\0'; i++) {
        result += i;
    }
    printf("%d", result);

    return 0;
}
```

<details>
<summary>정답</summary>

**_10_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. `char str2[50] = "teststring"`: 문자 50개짜리 문자 배열 `str2`를 선언
2. `sumFn(str2, str1)` 함수 호출
   - `while (*s)`: 매개변수 `s`가 `truethy`인동안 반복
   - `*d = *s; d++; s++`: `*s`가 `\0`이 때까지 반복되며, `*d`의 문자가 덮어씌워짐
   - `*d = '\0'`: `d` 문자열이 여기서 종료됨
   - first
3. `for (int i = 0; str2[i] != '\0'; i++)`: 문자열이 끝날 때까지 반복
4. `result += i`: 문자열의 길이만큼 i를 더함
   - 0+1+2+3+4=10
5. <b>출력</b>: 10

- C에서는 문자열(string)이라는 별도의 자료형이 없음
- 문자열은 단순히 `char` 배열로 표현되고, 그 끝을 알리기 위해 특별히 널 종료문자(`'\0'`)를 넣는다.

</div>

</details>

## 16. 아래는 소프트웨어 설계에 대한 내용이다. 내용을 읽고 괄호안에 알맞는 답을 작성하시오.

- 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해, 제어를 통신하거나 제어 요소를 전달하는 결합도이다.
- 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생한다.

<details>
<summary>정답</summary>

**_제어_**

</details>

## 17. 다음은 Java에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력 값을 작성하시오.

```java
class Main {
    public static void main(String[] args) {
        String str = "abacabcd";
        boolean[] seen = new boolean[256];
        System.out.print(calculFn(str, str.length()-1, seen));
    }

    public static String calculFn(String str, int index, boolean[] seen) {
        if(index < 0) return "";
        char c = str.charAt(index);
        String result = calculFn(str, index-1, seen);
        if(!seen[c]) {
            seen[c] = true;
            return c + result;
        }
        return result;
    }
}
```

<details>
<summary>정답</summary>

**_dcba_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. `boolean[] seen = new boolean[256]`: 256 길이의 불린 배열 `seen` 선언
2. `calculFn()` 함수 호출
   - `char c = str.charAt(index)`: 문자열 `str`의 `index`에 해당하는 문자를 가져옴
   - `String result = calculFn(str, index-1, seen)`: `index`를 1 줄이고, 함수를 재귀호출
   - `if(!seen[c])`: `seen[c]`값이 `false`라면
     - `seen[c] = true; return c + result`: `true`를 할당하고, 문자를 `result`에 더함
3. `calculFn(str, str.length()-1)`
   - 결과적으로 문자열 `"abacabcd"`를 역순으로 순회하며, 중복되지 않는 선에서 문자를 더함
   - dcba
4. <b>출력</b>: dcba

</div>

</details>

## 18. 다음은 C언어에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력 값을 작성하시오.

```c
#include <stdio.h>

void swap(int a, int b) {
    int t = a;
    a = b;
    b = t;
}

int main() {

    int a = 11;
    int b = 19;
    swap(a, b);

    switch(a) {
        case 1:
            b += 1;
        case 11:
            b += 2;
        default:
            b += 3;
        break;
    }

    printf("%d", a-b);
}
```

<details>
<summary>정답</summary>

**_5_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. `int a = 11; int b = 19` 정수 변수 초기화
2. `swap(a, b)`: a와 b의 값을 치환하는 함수이지만, 반환하는 값도 없고, 주소가 아닌 값을 매개변수로 받기 때문에 `a`와 `b`는 변하지 않는다.
3. `switch(a)`
   - `case 11: b += 2`: `a`는 11이므로 `case 11`을 실행 (19+2=21)
   - `break`문이 없으므로
   - `default: b += 3` (21+3=24)
4. <b>출력</b>: -13

</div>

</details>

## 19. 다음은 C언어의 구조체에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력 값을 작성하시오.

```c
#include <stdio.h>

struct node {
    int n1;
    struct node *n2;
};

int main() {

    struct node a = {10, NULL};
    struct node b = {20, NULL};
    struct node c = {30, NULL};

    struct node *head = &a;
    a.n2 = &b;
    b.n2 = &c;

    printf("%d\n", head->n2->n1);

    return 0;
}
```

<details>
<summary>정답</summary>

**_20_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. 연결리스트 형태의 구조체 `node`
2. `struct node *head = &a`: `a` 노드를 헤드로 지정
3. `a.n2 = &b; b.n2 = &c`: a->b->c 순서로 연결
4. `head->n2->n1` = `a.n2.n1` = `b.n1`
5. <b>출력</b>: 20

</div>

</details>

## 20. 다음은 Java에 대한 문제이다. 아래 코드를 확인하여 알맞는 출력 값을 작성하시오.

```java
class Main {
    public static void main(String[] args) {
        String str = "ITISTESTSTRING";
        String[] result = str.split("T");
        System.out.print(result[3]);
    }
}
```

<details>
<summary>정답</summary>

**_S_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. `String[] result = str.split("T")`: 문자열 `str`을 `"T"`를 기준으로 나누어 배열 초기화
   - `[I, IS, ES, S, RING]`
2. `result[3]`은 `S`
3. <b>출력</b>: S

</div>

</details>

# 정보처리기사 실기 2024년 1회

## 1. 다음 Java 코드에서 알맞는 출력 값을 작성하시오.

```java
class Connection {
    private static Connection _inst = null;
    private int count = 0;

    static public Connection get() {
        if(_inst == null) {
            _inst = new Connection();
            return _inst;
        }
        return _inst;
    }

    public void count() {
         count++;
    }

    public int getCount() {
         return count;
    }
}

public class main {
    public static void main(String[] args) {

        Connection conn1 = Connection.get();
        conn1.count();

        Connection conn2 = Connection.get();
        conn2.count();

        Connection conn3 = Connection.get();
        conn3.count();

        conn1.count();
        System.out.print(conn1.getCount());
    }

}
```

<details>
<summary>정답</summary>

**_4_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. `Connection.get()`: 클래스 `Connection`의 정적 메서드 `get`을 호출
   - 정적 변수 `_inst`의 값이 null이라면
   - `_inst = new Connection()` 인스턴스를 생성
   - 그리고 해당 인스턴스를 반환
2. `conn1.count()`: count에 1을 더함 (0+1=1)
3. `conn2.count()`: 싱글톤 패턴이기 때문에 같은 인스턴스를 공유 (1+1=2)
4. `conn3.count(); conn1.count()`: (2+1+1=4)
5. `conn1.getCount()`: `count`의 값을 반환 (4)
6. <b>출력</b>: 4

</div>

</details>

## 2. 다음 C언어 코드에서 알맞는 출력 값을 작성하시오.

```c
#include <stdio.h>
int main() {
    int v1 = 0, v2 = 35, v3 = 29;

    if(v1 > v2 ? v2 : v1) {
        v2 = v2 << 2;
    }else{
        v3 = v3 << 2;
    }

    printf("%d", v2+v3);
}
```

<details>
<summary>정답</summary>

**_151_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. `int v1 = 0, v2 = 35, v3 = 29` 정수 변수 초기화
2. `if(v1 > v2 ? v2 : v1)`: `v1`이 `v2`보다 크면 `v2`를 반환, 아니라면 `v1`을 반환
   - 0 > 35 이기 때문에 `v1` 0을 반환
   - 조건문이 `false`이기 때문에 `else`문을 실행
   - `v3 = v3 << 2`: `29 << 2 = 11101 << 2`는 1110100이 되고, `v3`는 64+32+16+4=116
   - 35 + 116 = 151
3. <b>출력</b>: 151

</div>

</details>

## 3. 다음은 응집도와 관련해서 보기에서 응집도가 높은 순으로 나열하시오.

보기

ㄱ. 기능 ㄴ. 교환 ㄷ. 우연 ㄹ. 시간

<details>
<summary>정답</summary>

**_ㄱ. 기능 ㄴ. 교환 ㄹ. 시간 ㄷ. 우연_**

</details>

## 4. 다음은 C언어에 대한 문제이다. 알맞는 출력 값을 작성하시오.

```c
#include <stdio.h>
#include <string.h>

void reverse(char* str){
    int len = strlen(str);
    char temp;
    char*p1 = str;
    char*p2 = str + len - 1;
    while(p1<p2){
        temp = *p1;
        *p1 = *p2;
        *p2 = temp;
        p1++;
        p2--;
    }
}

int main(int argc, char* argv[]){
    char str[100] = "ABCDEFGH";

    reverse(str);

    int len = strlen(str);

    for(int i=1; i<len; i+=2){
        printf("%c",str[i]);
    }

    printf("\n");

    return 0;

}
```

<details>
<summary>정답</summary>

**_GECA_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. `char str[100] = "ABCDEFGH"`: 길이가 100인 문자열 배열 `str`을 초기화
2. `reverse` 함수 호출
   - `char*p1 = str`: 문자열 배열의 포인터 변수 `p1`
   - `char*p2 = str + len - 1`: 문자열 마지막 문자의 포인터 변수 `p2`
   - `while(p1<p2)`: `p1`이 `p2`보다 클 동안
     - `temp = *p1; *p1 = *p2; *p2 = temp`: `p1`의 값과 `p2`의 값을 치환
     - `p1++; p2--`: 치환한 후에 각 포인터를 높이고, 낮춤
   - `reverse(str)`: 문자열 `"ABCDEFGH"`과 뒤집어고, 주소는 `str` 배열의 뒤에 위치
3. `for(int i=1; i<len; i+=2)`: 1부터 2씩 증가하며 반복 (홀수)
4. `str[i]`: `i`는 홀수 인덱스만 가진다.
   - i = 1, 3, 5, 7
   - GECA
5. <b>출력</b>: GECA

</div>

</details>

## 5. 아래 그림에서의 네트워크에서 라우터을 통한 할당 가능한 2번, 4번, 5번의 IP를 작성하시오.

![5번 문제 사진](image-22.png)

1. 192.168.35.3/24
2. 129.200.10.16/22
3. 192.168.36.24/24

<details>
<summary>정답</summary>

**_2) 192.168.35.72 4) 129.200.8.249 5) 192.168.36.249_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

- 1번(192.168.35.3/24)은 192.168.35.0/24 네트워크
- 3번(129.200.10.16/22)은 129.200.8.0/22 네트워크
- 6번(192.168.36.24/24)은 192.168.36.0/24 네트워크

같은 네트워크 내의 장비들은 IP 대역이 동일해야 한다.

- 2번은 1번(192.168.35.0)과 같은 <b style="text-decoration:underline">192.168.35.72</b>
- 4번은 3번(129.200.8.0)과 같은 <b style="text-decoration:underline">129.200.8.249</b>
- 5번은 6번(192.168.36.0)과 같은 <b style="text-decoration:underline">192.168.36.249</b>

</div>

</details>

## 6. 아래 표에서 나타나고 있는 정규형을 작성하시오.

![6번 문제 사진](image-23.png)

<details>
<summary>정답</summary>

**_제 3 정규형_**

</details>

## 7. 아래의 내용에서 설명하는 네트워크 용어를 영문 약자로 작성하시오.

1. 대표적인 링크 상태 라우팅 프로토콜이다. 이것은 인터넷에서 연결된 링크의 상태를 감시하여 최적의 경로를 선택한다는것이다.

2. 단일 자율 시스템 내에서 라우팅 정보를 배포하는 데 사용되는 내부 게이트웨이 프로토콜이다.

3. 모든 대상에 도달하기 위한 최단 경로를 구축하고 계산하며 최단 경로는 Dijkstra 알고리즘을 사용하여 계산된다.

<details>
<summary>정답</summary>

**_OSPF_**

<b>키워드: 네트워크, 최단/최적 경로, 다익스트라</b>

</details>

## 8. 아래 내용의 각각의 설명에 대한 답을 작성하시오.

(1) 조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 튜플만 반환한다.

(2) 조건이 정확하게 '=' 등호로 일치하는 결과를 반환한다.

(3) ( (2) ) 조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성을 제거한 결과를 반환한다.

<details>
<summary>정답</summary>

**_1) 세타조인 2) 동등조인 3) 자연조인_**

</details>

## 9. 다음은 운영체제 페이지 순서를 참고하여 할당된 프레임의 수가 3개일 때 LRU와 LFU 알고리즘의 페이지 부재 횟수를 작성하시오.

페이지 참조 순서 : 1, 2, 3, 1, 2, 4, 1, 2, 5, 7

<details>
<summary>정답</summary>

**_6,6_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

- LRU(Least Recently Used): 가장 오랫동안 사용 안한게 버려짐

  - 1 (부재 1)
  - 1 2 (부재 2)
  - 1 2 3 (부재 3)
  - 2 3 1
  - 3 1 2
  - 1 2 4 (부재 4)
  - 2 4 1
  - 4 1 2
  - 1 2 5 (부재 5)
  - 2 5 7 (부재 6)

- LFU(Least Frequently Used): 사용 빈도수가 낮은 애가 버려짐
  - 1(1) (부재 1)
  - 1(1) 2(1) (부재 2)
  - 1(1) 2(1) 3(1) (부재 3)
  - 1(2) 2(1) 3(1)
  - 1(2) 2(2) 3(1)
  - 1(2) 2(2) 4(1) (부재 4)
  - 1(3) 2(2) 4(1)
  - 1(3) 2(3) 4(1)
  - 1(3) 2(3) 5(1) (부재 5)
  - 1(3) 2(3) 7(1) (부재 6)

</div>

</details>

## 10.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 11.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 12.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 13.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 14.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 15.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 16.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 17.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 18.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 19.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 20.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

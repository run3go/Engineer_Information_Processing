# 정보처리기사 실기 2025년 2회

## 1. 다음은 파일 구조와 관련된 설명이다. 설명을 읽고 괄호 안에 들어갈 가장 알맞은 용어를 작성하시오.

![1번 문제 사진](image-4.png)

데이터베이스의 물리 설계 시, 레코드에 접근하는 방법은 순차 접근 방법, [   ] 방법, 해싱 방법 등이 있다.

이 중 [   ] 방법은 레코드의 키 값과 포인터를 쌍으로 묶어 저장하며 검색 시 키 값을 기준으로 빠르게 탐색할 수 있도록 설계되어 있다.

이 방식은 검색 속도가 빠르며 쌍으로 구성된 자료 구조를 사용하여 해당 키가 가리키는 주소를 통해 원하는 레코드를 직접 찾을 수 있다.

<details>
<summary>정답</summary>

**_인덱스_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

<b>파일 구조</b>: 데이터를 저장하고 관리하는 방식으로, 효율적인 데이터 접근과 처리를 위해 사용된다.
파일 구조에 따라 <b style="text-decoration:underline">데이터의 저장, 접근, 검색, 수정 속도</b>가 달라지므로, 절저한 구조를 선택하는 것이 중요하다.

- <b>순차 파일(Sequential File)</b>: <b style="text-decoration:underline">레코드를 일정한 논리적 순서에 따라 저장</b>하는 방식

  - 데이터가 연속된 물리적 공간에 저장되므로 <b style="text-decoration:underline">처리 속도가 빠르다</b>.
  - 레코드를 추가할 경우, 기존 데이터 <b style="text-decoration:underline">끝부분</b>에만 삽입된다.
  - 특정 데이터를 검색할 때 처음부터 순차적으로 찾아야 하므로, <b style="text-decoration:underline">검색 속도가 느릴 수 있다</b>.
  - 주로 <b style="text-decoration:underline">테이프 저장 장치</b>에서 많이 사용된다.

- <b>직접 파일(Direct File)</b>: <b style="text-decoration:underline">레코드를 임의의 물리적 공간에 저장하는 방식</b>으로, 특정 데이터를 빠르게 찾을 수 있다.

  - <b style="text-decoration:underline">해시 함수를 사용하여 데이터의 저장 위치를 결정</b>하므로 검색 속도가 빠르다.
  - 특정 데이터만 빠르게 조회하는 작업에 유리하지만, 데이터가 많아지면 충돌 문제가 발생할 수 있다.
  - 주로 <b style="text-decoration:underline">온라인 트랜잭션 처리 시스템(OLTP)</b>에서 많이 사용된다.

- <b>색인 순차 파일(Indexed Sequential File)</b>: <b style="text-decoration:underline">순차 파일과 직접 파일의 장점을 결합한 방식</b>으로, <b style="text-decoration:underline">색인</b>을 사용해 검색 속도를 향상 시킨다.
  - 레코드는 순차적으로 저장되지만, <b style="text-decoration:underline">색인을 통해 원하는 데이터를 빠르게 검색</b>할 수 있다.
  - 파일이 크더라도 색인을 활용하면 전체 데이터를 검색하지 않아도 된다.
  - 주로 <b style="text-decoration:underline">대형 데이터베이스 시스템</b>에서 사용된다.

</div>

</details>

## 2. 다음은 데이터베이스 릴레이션의 구성 요소 중 하나에 대한 설명이다. 설명을 읽고 보기에서 알맞은 기호를 골라 작성하시오.

릴레이션(Relation)에서 열(Column)을 의미하며 데이터 항목의 속성(Attribute) 또는 특성을 나타낸다.

각 열은 고유한 이름을 가지며 특정 도메인(Domain)에서 정의된 값을 갖는다.

예를 들어 "학생" 릴레이션에서 학번, 이름, 전공 등은 각각 하나의 열이며 이 열들은 학생의 고유한 속성을 나타낸다.

이 개념은 파일 구조에서의 필드(Field)에 해당하며 릴레이션에서 행(Row, Tuple)의 구성 요소가 된다.

[보기]
ㄱ. Cardinality
ㄴ. Domain
ㄷ. Attribute
ㅁ. Degree
ㅂ. Schema
ㅅ. Tuple

<details>
<summary>정답</summary>

**_ㄷ Atrribute_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

- <b>Cardinality</b>: 튜플의 수를 나타냄
- <b>Domain</b>: 특정 속성이 가질 수 있는 값의 전체 집합을 의미함
- <b>Attribute</b>: 릴레이션의 열을 의미하며, 데이터의 속성 또는 특성을 나타냄
- <b>Degree</b>: 열의 수를 의미함
- <b>Schema</b>: 릴레이션의 구조 전체를 정의하는 것으로, 여러 속성들의 집합을 포함
- <b>Tuple</b>: 릴레이션의 각 행, 즉 개별 레코드를 나타냄

</div>

</details>

## 3. 다음은 정보보안 관련 문제이다. 아래 내용을 보고 알맞는 단어를 작성하시오.

원격 접속과 관련된 보안 프로토콜이며 암호화된 통신을 제공하는 보안 접속용 프로토콜이다.
공개키 기반의 인증 방식을 사용하며 암호화된 데이터 전송을 지원한다.
주로 원격 서버에 안전하게 접속할 때 사용되며 기본 포트 번호는 22번이다.
Telnet의 보안 취약점을 보완한 대안으로 널리 사용된다.

<details>
<summary>정답</summary>

**_SSH_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

<b>SSH(SecureSHell)</b>: 네트워크를 통해 다른 컴퓨터에 안전하게 접속하고 명령을 실행하며 파일을 전송하는데 사용되는 네트워크 프로토콜이다.

- TCP 기본 포트 번호는 22번이다.
- Telnet의 보안 취약점을 보완한 대안으로 널리 사용된다.
- 공개키 기반 인증

</div>

</details>

## 4. 스케줄링 알고리즘에 관한 다음 설명을 읽고 (1)과 (2)에 알맞은 스케줄링 알고리즘의 명칭을 각각 쓰시오.

(1) CPU burst 시간이 짧은 프로세스를 우선적으로 처리하는 스케줄링 방식이다. "Shortest Next CPU Burst"라고도 불리며 선점형 또는 비선점형으로 구현될 수 있다.

(2) 위의 스케줄링 방식을 선점형으로 구현한 형태로 실행 중인 프로세스보다 더 짧은 burst 시간을 가진 프로세스가 도착하면 현재 CPU를 선점한다.

<details>
<summary>정답</summary>

**_(1) SJF (2) SRT_**

</details>

## 5. 다음은 Java의 문제이다. 아래 코드를 보고 알맞는 출력값을 작성하시오.

```java
public class Main {
    public static void change(String[] data, String s){
        data[0] = s;
        s = "Z";
    }

    public static void main(String[] args) {
        String data[] = { "A" };
        String s = "B";

        change(data, s);
        System.out.print(data[0] + s);
    }
}

```

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. 문자열 배열 `data`를 `{ "A" }`로 선언
2. 문자열 변수 `s`를 `"B"`로 초기화
3. `change(data, s)`함수를 호출
4. <b>data[0] = s</b>: 배열 `data`의 인덱스 0번째 값을 `s`로 변경 (data = `{ "B" }`)
   - 배열은 값이 아닌 값의 주소를 할당하므로, main 함수의 `data` 배열의 값이 직접 변경됨
5. <b>s = "Z"</b>: 매개변수 `s`에 `"Z"`를 할당
   - 매개변수 `s`는 main 함수의 변수 `s`와는 다른 change 함수의 변수 `s`이다
6. <b>출력</b>: BB

</div>

</details>

## 6. 다음은 IP 주소와 서브넷 마스크에 관한 문제이다. 주어진 정보를 참고하여 괄호 안에 들어갈 알맞은 값을 쓰시오.

호스트의 IP 주소가 223.13.234.132이고 서브넷 마스크가 255.255.255.192일 때 다음 물음에 답하시오.

이 호스트가 속한 네트워크 주소는 223.13.234.( ① )이다.

이 네트워크에서 사용 가능한 호스트 수는 ( ② )개이다.

(단, 네트워크 주소와 브로드캐스트 주소는 제외한다.)

<details>
<summary>정답</summary>

**_1.128 2.62_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

<b>서브넷 마스크</b>가 255.255.255.192 일 때, 이 서브넷을 `/26`이라 부른다.

네 번째 옥텟은 192(11000000)으로 표현할 수 있으며, 앞의 2비트는 네트워크를 나타내고, 나머지 6비트가 호스트를 나타낸다.

가능한 서브넷의 마지막 옥텟 값은: 0, 64, 128, 192가 되고,
호스트의 주소가 132이기 때문에 129~191 범위가 속한 네트워크 주소는 `128`이 된다.

이 네트워크에서 사용 가능한 호스트 수는 129에서 191 사이이기 때문에 191 - 129 = `62`

</div>

</details>

## 7. 다음은 디자인 패턴에 관한 문제이다. 아래 내용을 보고 알맞는 단어를 작성하시오.

어떤 객체에 대한 접근을 제어하거나 추가적인 기능을 부여하기 위해 해당 객체의 대리 객체를 사용하는 방식의 디자인 패턴이다.

실제 객체에 대한 접근 전에 필요한 작업을 수행할 수 있으며 실제 객체의 생성을 지연시켜 메모리와 자원을 절약할 수 있다.

또한, 실제 객체를 감추어 정보은닉을 강화할 수 있다는 장점이 있다.

<details>
<summary>정답</summary>

**_프록시_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

<b>프록시 패턴</b>: 대상 원본 객체를 <b style="text-decoration:underline">대리하여 대신 처리하게 함으로써 로직의 흐름을 제어</b>하는 행동 패턴

<b>키워드: 대리</b>

</div>

</details>

## 8. 다음은 웹 데이터 교환 방식에 관한 문제이다. 아래 설명을 읽고 괄호 안에 들어갈 알맞은 용어를 작성하시오.

<details>
<summary>정답</summary>

**_AJAX_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

<b>키워드: 비동기, 자바스크립트, XML</b>

</div>

</details>

## 9. 다음은 Java언어의 문제이다. 아래 코드를 보고 알맞는 출력값을 작성하시오.

```java
public class Main {

    static interface F {
        int apply(int x) throws Exception;
    }

    public static int run(F f) {
        try {
            return f.apply(3);
        } catch (Exception e) {
            return 7;
        }
    }

    public static void main(String[] args) {

        F f = (x) -> {
            if (x > 2) {
                throw new Exception();
            }
            return x * 2;
        };

        System.out.print(run(f) + run((int n) -> n + 9));
    }

}
```

<details>
<summary>정답</summary>

**_19_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. <b>run(f)</b>: `f.apply(3)`을 호출
2. <b>x > 2</b>: 3은 2보다 크므로, 예외 발생
3. 예외가 발생했으므로, 7을 반환
4. <b>run((int n) -> n + 9)</b>: `f.apply(3)`을 호출
5. <b>n + 9</b>: 3 + 9는 12이고, 예외는 없으므로 12를 그대로 반환
6. <b>출력</b>: 19

</div>

</details>

## 10. 다음은 Java언어의 문제이다. 아래 코드를 보고 알맞는 출력값을 작성하시오.

```java
public class Main{

    public static class Parent {

        public int x(int i) { return i + 2; }
        public static String id() { return "P";}

    }

    public static class Child extends Parent {

        public int x(int i) { return i + 3; }
        public String x(String s) { return s + "R"; }
        public static String id() { return "C"; }

    }

    public static void main(String[] args) {

        Parent ref = new Child();
        System.out.println(ref.x(2) + ref.id());

    }

}
```

<details>
<summary>정답</summary>

**_5P_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. <b>Parent ref = new Child()</b>: 실제 객체는 `Child` 타입이지만 컴파일 타입은 `Parent`이다.
2. <b>ref.x(2)</b>: `x(int)`는 인스턴스 메서드이므로, 실제 객체 타입(`Child`)에 따라 호출
3. <b>return i + 2</b>: `2 + 3 = 5` 5를 반환
4. <b>ref.id()</b>: 정적 메서드는 클래스(컴파일) 기준으로 호출
5. <b>return "P"</b>: 문자열 `"P"`를 반환
6. <b>출력</b>: 5P

</div>

</details>

## 11. 다음 아래 제어 흐름 그래프가 분기 커버리지를 만족하기 위한 테스팅 순서를 쓰시오.

![11번 문제 사진](image-6.png)

<details>
<summary>정답</summary>

**_124567/1234561_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 12. 다음은 C언어의 문제이다. 아래 코드를 보고 알맞는 출력값을 작성하시오.

```c
#include <stdio.h>
#define SIZE 3

typedef struct {
    int a[SIZE];
    int front;
    int rear;
} Queue;

void enq(Queue* q, int val){
    q->a[q->rear] = val;
    q->rear = (q->rear + 1) % SIZE;
}

int deq(Queue* q) {
    int val = q->a[q->front];
    q->front = (q->front + 1) % SIZE;
    return val;
}

int main() {
    Queue q = {{0}, 0, 0};

    enq(&q,1); enq(&q,2); deq(&q); enq(&q, 3);

    int first = deq(&q);
    int second = deq(&q);
    printf("%d 그리고 %d", first, second);

    return 0;
}
```

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

`(*q).rear = q->rear`

`&q`는 `q`의 주소값

1. `Queue` 구조체를 정의
2. `enq()` 메서드는 매개변수로 구조체 `Queue`와 정수 변수 `val`을 받음
   - <b>q->a[q->rear] = val</b>: 배열 `a`의 맨 끝에 값을 넣음
   - <b>q->rear = (q->rear + 1) % SIZE</b>: 삽입 후, 변수 `rear`에 1을 더함 (`% SIZE` 때문에 `rear`의 값은 배열의 크기를 넘길 수 없음)
3. `deq()` 메서드는 매개변수로 구조체 `Queue`를 받음
   - <b>int val = q->a[q->front]</b>: 배열의 첫번째 원소 값을 정수 변수 `val`에 할당
   - <b>q->front = (q->front + 1) % SIZE</b>: `rear`랑 마찬가지로 1을 더함
   - <b>return val</b>: `val`을 반환
4. <b>enq(&q,1); enq(%q,2); deq(&q); enq(&q,3);</b>: 배열에 1과 2를 넣은 후, 1을 빼고 3을 넣음 (`{{2, 3}, 1, 3}`)
5. `first`와 `second` 모두 `deq`를 실행하므로 `first`는 2, `second`는 3이 된다.
6. <b>출력</b>: 2 그리고 3

</div>

</details>

## 13. 라운드로빈(RR) 방식을 이용하고 아래 내용을 참고하여 평균대기시간을 구하시오.

![13번 문제 사진](image-7.png)

운영체제에서 라운드로빈(Round Robin, RR) 스케줄링은 각 프로세스에 동일한 시간 할당량(타임 퀀텀)을 순차적으로 부여하며 CPU를 할당하는 방식이다.

다음은 4개의 프로세스가 서로 다른 시간에 도착하며 각기 다른 실행 시간을 가지는 상황이다. 이때 시간 할당량은 4ms이고 컨텍스트 스위칭 시간은 무시한다고 가정한다.

아래 정보를 바탕으로 라운드로빈(RR) 방식으로 CPU 스케줄링을 수행할 경우 모든 프로세스의 평균 대기시간(Average Waiting Time)은 얼마인가?

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

- 타임 퀀텀 = 4ms
- 컨텍스트 스위칭 시간 = 0

1. <b>0ms~4ms: P1 실행</b>
   - P1 실행 -> 8 - 4 -> 남은 시간 4
   - <b>현재 큐</b>: [P2, P3, P4, P1]
2. <b>4ms~8ms: P2 실행</b>
   - P2 실행 -> 4 - 4 -> 남은 시간 0
   - <b>현재 큐</b>: [P3, P4, P1]
   - <b>P2 완료 시간</b>: 8
3. <b>8ms~12ms: P3 실행</b>
   - P3 실행 -> 9 - 4 -> 남은 시간 5
   - <b>현재 큐</b>: [P4, P1, P3]
4. <b>12ms~16ms: P4 실행</b>
   - P4 실행 -> 5 - 4 -> 남은 시간 1
   - <b>현재 큐</b>: [P1, P3, P4]
5. <b>16ms~20ms: P1 실행</b>
   - P1 실행 -> 4 - 4 -> 남은 시간 0
   - <b>현재 큐</b>: [P3, P4]
   - <b>P1 완료 시간</b>: 20
6. <b>20ms~24ms: P3 실행</b>
   - P3 실행 -> 5 - 4 -> 남은 시간 1
   - <b>현재 큐</b>: [P4, P3]
7. <b>24ms~25ms: P4 실행</b>
   - P4 실행 -> 1 - 1 -> 남은 시간 0
   - <b>현재 큐</b>: [P3]
   - <b>P4 완료 시간</b>: 25
8. <b>25ms~26ms: P3 실행</b>
   - P3 실행 -> 1 - 1 -> 남은 시간 0
   - <b>현재 큐</b>: []
   - <b>P3 완료 시간</b>: 26

<b>소요 시간(완료 - 도착)</b>: `20`(20-0) / `7`(8-1) / `24`(26-2) / `22`(25-3)

<b>대기 시간(소요 - 실행)</b>: `12`(20-8) / `3`(7-4) / `15`(24-9) / `17`(22-5)

<b>평균 대기 시간</b>: (12 + 3 + 15 + 17) / 4 = 47 / 4 = `11.75ms`

</div>

</details>

## 14. 다음은 C언어의 문제이다. 아래 코드를 보고 알맞는 출력값을 작성하시오.

```c
#include <stdio.h>

struct dat {
    int x;
    int y;
};

int main() {
    struct dat a[] = {{1, 2}, {3, 4}, {5, 6}};
    struct dat* ptr = a;
    struct dat** pptr = &ptr;

    (*pptr)[1] = (*pptr)[2];
    printf("%d 그리고 %d", a[1].x, a[1].y);

    return 0;
}
```

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. `dat` 구조체 배열 `a`에 값을 할당
2. `ptr` 포인터에 `a` 배열의 시작 주소를 할당
3. `pptr` 포인터에 `ptr`의 주소를 할당
4. `(*pptr)`은 `a`와 같다
5. `a[1] = a[2]` (`{{1, 2}, {5, 6}, {3, 4}}`)
6. <b>출력</b>: 5 그리고 6

</div>

</details>

## 15. 다음은 Java언어의 문제이다. 아래 코드를 보고 알맞는 출력값을 작성하시오.

```java
public class Main{
    public static class BO {
        public int v;
        public BO(int v) {
            this.v = v;
        }
    }
    public static void main(String[] args) {
        BO a = new BO(1);
        BO b = new BO(2);
        BO c = new BO(3);
        BO[] arr = {a, b, c};
        BO t = arr[0];
        arr[0] = arr[2];
        arr[2] = t;
        arr[1].v = arr[0].v;
        System.out.println(a.v + "a" + b.v + "b" + c.v);
    }
}
```

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

1. `BO` 클래스로 `a`, `b`, `c` 인스턴스 생성
2. 각 인스턴스를 `arr` 배열에 할당
3. `arr[0]` 즉 `a` 인스턴스를 `t` 변수에 할당
4. `arr[0]`에 `arr[2]` 값, 즉 `c`를 할당
5. `arr[2]`에 `t` 변수를 할당 (`a`)
6. `arr[1].v = arr[0].v` `b.v`에 `c.v`를 할당
7. <b>출력</b>: 1a3b3

</div>

</details>

## 16.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 17.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 18.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 19.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>

## 20.

<details>
<summary>정답</summary>

**_a_**

</details>

<details>
<summary>정리</summary>
<div markdown="1">

</div>

</details>
